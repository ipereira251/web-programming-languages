Types of states: 
  local: one component 
  shared: shared among component
  server: from server APIs

useContext as an alternative to prop drilling
Steps: 
  Create context 
  Provide
  Use 

Use cases: 
  Appearance
  Auth status

Example: Get/set username 
const LoginContext = createContext(null);
myApp(){
  const [user, setUser] = useState(null);
  return(
    <LoginContext.Provider value={{user, setUser}}>
      <Form />
    </LoginContext.Provider>
  )
}
function Form(){
  return ( ... <LoginButton /> ...);
}
function LoginButton(){
  const {currentUser, setCurrentUser} = useContext(LoginContext);
  if(currentUser){
    return <p>You're logged in as {currentUser.name}.</p>;
  }
  return(
    //code to Auth
    //set username using setCurrentUser
  )
}
///State management libraries
Use subscribe/notify pattern, components subscribe to functions/values and createStore notifies on change
Zustand, focus on frontend states

useQuery: 
  Fetches data on component mount
  Caches to avoid re-fetch, only when stale
  Manages loading/error states automatically
  Synchronization across components
QueryFn must return a promise which resolves to data

useMutation: 
  Used to change DB data
  Must be called manually each time
  mutationFn and onSuccess to be defined
  onSuccess example: on uploading photo, invalidateQueries for number of photos a user has

express-async-handler to hide try/catches